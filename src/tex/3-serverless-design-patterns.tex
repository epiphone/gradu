\chapter{Serverless design patterns} \label{cha:patterns}

What kind of patterns are there for building serverless web application backends? \textcite{baldini17currentTrends} put the question as follows:

\begin{quote}
Will there be patterns for building serverless solutions? How do we combine low granularity basic building blocks of serverless into bigger solutions? How are we going to decompose apps into functions so that they optimize resource usage? For example how do we identify CPU-bound parts of applications built to run in serverless services? Can we use well-defined patterns for composing functions and external APIs? What should be done on the server vs. client (e.g., are thicker clients more appropriate here)? Are there lessons learned that can be applied from OOP design patterns, Enterprise Integration Patterns, etc.?
\end{quote}

\textcite{robert2016serverlessarchitectures} asks how big can FaaS functions get before they get unwieldy? Assuming we can atomically deploy a group of FaaS functions what are good ways of creating such groupings - do they map closely to how we’d currently clump logic into microservices or does the difference in architecture push us in a different direction? Extending this further, what are good ways of creating hybrid architectures between FaaS and traditional “always on” persistent server components? What are good ways of introducing BaaS into an existing ecosystem? And, for the reverse, what are the warning signs that a fully or mostly BaaS system needs to start embracing or using more custom server-side code?

Enterprise integration patterns, as serverless is all about integrations. \textcite{hohpe2004enterprise} present a number of asynchronous messaging architectures in the seminal book on EIP. While predating the whole serverless phenomenon the patterns are still relevant. Hohpe even demonstrated implementing one of his patterns on top of Google's serverless platform \href{http://www.enterpriseintegrationpatterns.com/ramblings/google_cloud_functions.html}{in a blog post}. E.g. patterns like Idempotent Receiver, Dead-letter Channel as well as the 4 more general integration styles of File Transfer, Shared Database, RPC and Messaging. Many patterns implemented internally by FaaS platforms already!

SOA patterns: FaaS functions are self-contained nanoservices these might have some relevance. SOA patterns \parencite{rotem12soa} include Saga, Decoupled Invocation and others. As with EIP, some patterns are already implemented by the FaaS platform.

FaaSification: \textcite{spillner17transformpython} describes an automated approach to transform monolithic Python code into modular FaaS units by partially automated decomposition. Doesn't really seem suitable for the web application migration process covered in this thesis but worth mentioning.

\section{Orchestration patterns} \label{sec:orchestrationPatterns}

Function orchestration and composition.

\subsection{Routing function} \label{subsubsec:routingFunction}

FaaS version of the GoF Component pattern.

\subsection{Function chain} \label{subsubsec:functionChain}

Chain functions to avoid timeouts.

\subsection{Periodic invocation} \label{subsubsec:periodicInvocation}

Schedule function invocations using cron-like systems.

\subsection{State machine} \label{subsubsec:stateMachine}

AWS Step Functions etc.

\subsection{Fat Client} \label{subsubsec:fatClient}

Let client orchestrate workflows.


\section{API/Integration patterns} \label{sec:apiPatterns}

Integrating with external systems.

\subsection{API composition} \label{subsubsec:apiComposition}

Hide multiple API calls under a single function.

\subsection{API aggregation} \label{subsubsec:apiAggregation}

Hide a sequential multi-step API call under a single function.

\subsection{API async} \label{subsubsec:apiAsync}

Turn a synchronized API into an async one.

\subsection{Legacy API Proxy/Staged migration} \label{subsubsec:legacyApi}

Replace a legacy API with a new one step by step, a.k.a. Strangler.

\subsection{Separate FaaS handler from core logic} \label
{subsubsec:separateHandler}

Separate FaaS handler core logic in code level.

\section{Data management/access patterns} \label{sec:dataManagementPatterns}

Managing state and accessing external resources.

\subsection{Externalized State} \label{subsubsec:externalizedState}

Store function state in external storage.

\subsection{Valet Key} \label{subsubsec:valetKey}

Sign tokens for clients to directly access resources.

\subsection{Least privilege IAM role} \label{subsubsec:LeastprivilegeIAMrole}

Minimize attack surface by reducing function access roles to bare minimum.

\section{Event patterns} \label{sec:eventPatterns}

Asynchronous messaging/event patterns.

\subsection{Event processing} \label{subsubsec:Eventprocessing}

Trigger a function as a result of event occurrence.

\subsection{Fan-out events} \label{subsubsec:FanoutEvents}

Trigger multiple actions from a single event.

\subsection{Fan-out/fan-in} \label{subsubsec:FanoutFanin}

Split event handling into parallel functions.

\subsection{Pipes and filters} \label{subsubsec:PipesAndFilters}

Handle event stream with a pipeline of small functions.

\section{Performance and scalability patterns} \label{sec:perfPatterns}

Address FaaS performance issues.

\subsection{Function warming} \label{subsubsec:FunctionWarming}

Ping a function intermittently to avoid cold starts.

\subsection{Oversized function} \label{subsubsec:OversizedFunction}

Choose maximum memory allocation to access faster CPU resources and improve cold start latency.

\subsection{Singleton} \label{subsubsec:Singleton}

Take advantage of function execution context to avoid reinitializing function dependencies.

\section{Resiliency and availability patterns} \label{sec:resiliencyPatterns}

Maximize serverless system resiliency.

\subsection{Bulkhead} \label{subsubsec:Bulkhead}

Isolate high-latency code into separate functions to avoid resource contention.

\subsection{Flow control/throttling} \label{subsubsec:Flow control/throttling}

Throttle invocations to avoid DDoSing yourself.

\subsection{Circuit breaker} \label{subsubsec:Circuit breaker}

Keep track of component availability to avoid cascading failures.

